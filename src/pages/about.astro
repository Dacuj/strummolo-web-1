<!-- ---
/* ABOUT.ASTRO
  Page: Punk Chest / Infinite Scroll
*/
---

<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>strummolo123 | Punk Chest</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
</head>
<body>

    <div class="noise-overlay"></div>

    <div id="canvas-container">
        <canvas id="chestCanvas"></canvas>
    </div>

    <header>
        <a href="/" class="back-btn">← Home</a>
    </header>

    <script>
        // @ts-nocheck
        const canvas = document.getElementById('chestCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let lastScrollY = window.scrollY;
        let ticking = false;

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Funzione di disegno principale
        function drawChest() {
            if (!width || !height || width <= 0 || height <= 0) return;

            // Pulisce il canvas
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);

            const screenArea = width * height;
            // Aumentato leggermente il numero totale di peli per compensare la distribuzione laterale
            const hairCount = Math.floor(screenArea * 0.0025); 

            const centerX = width / 2;
            const chestLevel = height * 0.35; // Livello Capezzoli
            const navelY = height * 0.75;     // Livello Ombelico
            
            const maxSpacing = 180;
            const nippleSpacing = Math.min(width * 0.22, maxSpacing);
            const nippleSize = Math.max(15, Math.min(width * 0.06, 30));

            // --- DEFINIZIONE ZONA "RASATA" ---
            // Calcoliamo il centro dell'area disponibile tra capezzoli e ombelico
            const abdomenTopLimit = chestLevel + nippleSize + 20;
            const abdomenBottomLimit = navelY - 30;
            const abdomenCenterY = (abdomenTopLimit + abdomenBottomLimit) / 2;

            // Definiamo dimensioni strette ("Tight bounding box") attorno al testo
            let boxWidth, boxHeight;
            if (width < 400) {
                // Mobile: Testo su due righe ("I HATE" / "NAPOLI")
                boxWidth = Math.min(width * 0.8, 160); // Ridotto rispetto al testo precedente
                boxHeight = 70; // Spazio sufficiente per 2 righe
            } else {
                // Desktop: Testo su una riga ("I HATE NAPOLI")
                boxWidth = 300; // Ridotto da 360 per adattarsi al testo più corto
                boxHeight = 50; // Spazio sufficiente per 1 riga
            }

            // Calcolo coordinate del rettangolo
            const shavedTop = abdomenCenterY - (boxHeight / 2);
            const shavedBottom = abdomenCenterY + (boxHeight / 2);
            const shavedLeft = centerX - (boxWidth / 2);
            const shavedRight = centerX + (boxWidth / 2);

            // 1. Peli
            ctx.beginPath(); 
            for (let i = 0; i < hairCount; i++) {
                let x = random(0, width);
                let y = random(0, height);
                
                // --- CONTROLLO ZONA RASATA ---
                if (x > shavedLeft && x < shavedRight && y > shavedTop && y < shavedBottom) {
                    continue; 
                }

                const distFromCenter = Math.abs(x - centerX);
                const safeZone = width < 600 ? width * 0.45 : width * 0.35;
                
                let drawProbability = 1;

                // --- DISTRIBUZIONE LATERALE ---
                if (distFromCenter > safeZone) {
                    drawProbability = 0.6; 
                }
                
                // Logica extra per la zona centrale
                if (y > chestLevel && y < navelY + 50) {
                     if (distFromCenter < width * 0.08) drawProbability = 1.8; 
                     else if (distFromCenter < width * 0.15) drawProbability = 0.9;
                } 

                if (Math.random() < drawProbability) {
                    const lenScale = width < 600 ? 0.8 : 1;
                    const length = random(8, 28) * lenScale;
                    let angle = Math.PI / 2; 
                    
                    if (x < centerX) angle += random(0.1, 0.5); 
                    if (x > centerX) angle -= random(0.1, 0.5);
                    
                    const distToNavel = Math.sqrt(Math.pow(x-centerX, 2) + Math.pow(y-navelY, 2));
                    if (distToNavel < 40) angle += random(-1, 1);

                    const distortion = (window.scrollY % 40) * 0.2; 
                    const startX = x + random(-1,1);
                    const startY = y + random(-1,1);
                    
                    ctx.moveTo(startX, startY);
                    const cpX = startX + Math.cos(angle + random(-0.5, 0.5)) * (length/2) + distortion;
                    const cpY = startY + Math.sin(angle + random(-0.5, 0.5)) * (length/2);
                    const endX = startX + Math.cos(angle) * length;
                    const endY = startY + Math.sin(angle) * length;
                    
                    ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                }
            }
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            ctx.strokeStyle = `rgba(230, 230, 230, 0.7)`; 
            ctx.stroke();

            // --- DISEGNO SCRITTA "I HATE NAPOLI" ---
            ctx.save();
            ctx.translate(centerX, abdomenCenterY); // Usiamo il centro calcolato
            
            // Lista di font "duri" / brutalisti
            const brutalFonts = [
                '"Press Start 2P"', 
                '"VT323"', 
                '"Courier New"', 
                '"Arial Black"', 
                '"Impact"', 
                '"Times New Roman"', 
                '"Verdana"', 
                'monospace'
            ];

            const scrollIndex = Math.floor(window.scrollY / 150);
            const currentFontFamily = brutalFonts[scrollIndex % brutalFonts.length];

            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // Disegna il testo
            if (width < 400) {
                 ctx.font = `16px ${currentFontFamily}`; 
                 ctx.fillText("I HATE", 0, -15);
                 ctx.fillText("NAPOLI", 0, 15);
            } else {
                 ctx.font = `24px ${currentFontFamily}`; 
                 ctx.fillText("I HATE NAPOLI", 0, 0);
            }
            
            ctx.restore();

            // 2. Anatomia
            drawNipple(centerX - nippleSpacing, chestLevel, nippleSize);
            drawNipple(centerX + nippleSpacing, chestLevel, nippleSize);
            drawNavel(centerX, navelY, nippleSize * 0.9);

            // 3. Graffi / Sporcizia
            for(let j=0; j<40; j++) {
                ctx.beginPath();
                let sx = random(0, width);
                let sy = random(0, height);
                // Evita di disegnare sporcizia sopra la scritta
                if (sx > shavedLeft && sx < shavedRight && sy > shavedTop && sy < shavedBottom) continue;

                const r = random(1, 3);
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${random(0.1, 0.3)})`;
                ctx.fill();
            }
        }

        function drawNipple(cx, cy, size) {
            const numRings = 12;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.9)"; 
            
            for(let i=0; i<numRings; i++) {
                ctx.beginPath();
                const r = (size * 0.3) + (i * (size/numRings)) + random(-2, 2);
                for (let a = 0; a <= Math.PI * 2; a += 0.3) { 
                    const x = cx + Math.cos(a) * r + random(-2, 2);
                    const y = cy + Math.sin(a) * r + random(-2, 2);
                    if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.lineWidth = random(0.8, 1.8);
                ctx.stroke();
            }
            
            // Centro
            ctx.beginPath();
            for(let k=0; k<20; k++) {
                const r = random(0, size * 0.3);
                const a = random(0, Math.PI * 2);
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(a)*r, cy + Math.sin(a)*r);
            }
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawNavel(cx, cy, size) {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.85)";
            ctx.beginPath();
            let angle = 0;
            let r = 1;
            
            for (let i = 0; i < 30; i++) {
                 const x = cx + Math.cos(angle) * r + random(-1,1);
                 const y = cy + Math.sin(angle) * (r * 0.7) + random(-1,1);
                 if(i===0) ctx.moveTo(x,y);
                 else ctx.lineTo(x, y);
                 angle += 0.5;
                 r += 0.3;
            }
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(cx - size, cy - size*0.6);
            ctx.quadraticCurveTo(cx, cy - size*1.2, cx + size, cy - size*0.6);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.stroke();
        }

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            
            if (width === 0 || height === 0) {
                setTimeout(resize, 100);
                return;
            }

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            drawChest();
        }

        // --- GESTIONE SCROLL INFINITO ---
        function checkInfiniteScroll() {
            const scrollPos = window.scrollY;
            const docHeight = document.body.scrollHeight;
            const winHeight = window.innerHeight;
            const buffer = 100; // Pixel di margine prima del loop

            // Se arriviamo quasi in fondo, saltiamo indietro (loop)
            if (scrollPos + winHeight >= docHeight - buffer) {
                window.scrollTo(0, buffer + 1);
            }
            // Se arriviamo in cima, saltiamo quasi in fondo
            else if (scrollPos <= 0) {
                window.scrollTo(0, docHeight - winHeight - buffer - 1);
            }
        }

        window.addEventListener('scroll', () => {
            // Effetto glitch/distorsione
            const currentScroll = window.scrollY;
            const threshold = 10; 

            if (Math.abs(currentScroll - lastScrollY) > threshold) {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        drawChest();
                        checkInfiniteScroll(); // Controlla il loop
                        ticking = false;
                    });
                    ticking = true;
                }
                lastScrollY = currentScroll;
            } else {
                // Controllo immediato per il loop anche su piccoli scroll
                checkInfiniteScroll();
            }
        });

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resize, 100);
        });
        
        window.onload = () => {
            resize();
            // Start scroll middle
            window.scrollTo(0, 100);
        };
        // Backup per Astro transitions
        document.addEventListener('DOMContentLoaded', resize);

    </script>
</body>
</html>

<style is:global>
    /* --- IMPOSTAZIONI DI BASE & SFONDO --- */
    body, html {
        margin: 0;
        padding: 0;
        width: 100%;
        /* Altezza molto grande per permettere lo scroll, gestita poi dal JS per il loop */
        height: 5000px; 
        background-color: #050505; 
        font-family: 'Courier New', Courier, monospace;
        -webkit-overflow-scrolling: touch;
        /* Cursore personalizzato */
        cursor: url('https://cur.cursors-4u.net/nature/nat-10/nat926.cur'), auto;
        
        /* --- NASCONDI SCROLLBAR (Richiesta 1) --- */
        /* Per Firefox */
        scrollbar-width: none;
        /* Per IE e Edge */
        -ms-overflow-style: none;
    }

    /* Per Chrome, Safari e Opera */
    body::-webkit-scrollbar {
        display: none;
    }

    /* Il canvas è sullo sfondo fisso */
    #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1; 
        pointer-events: none; 
        filter: contrast(150%) brightness(120%);
    }

    /* Overlay rumore */
    .noise-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
        opacity: 0.15;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.4' fill='white'/%3E%3C/svg%3E");
        mix-blend-mode: screen; 
    }

    /* Elementi Interattivi */
    a, button, .logo, .nav-link {
        cursor: url('https://cur.cursors-4u.net/nature/nat-10/nat926.cur'), pointer;
    }

    /* --- HEADER & NAVBAR --- */
    /* --- HEADER (Minimal) --- */
    header {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        padding: 20px;
        z-index: 1000;
        display: flex;
        justify-content: space-between;
        pointer-events: none; 
    }

    .back-btn {
        pointer-events: auto;
        text-decoration: none;
        font-family: 'Press Start 2P', cursive;
        font-size: 0.7rem;
        color: #fff;
        background: #000;
        padding: 10px;
        border: 1px solid #333;
        transition: all 0.2s;
        text-transform: uppercase;
    }

    .back-btn:hover {
        background: #fff;
        color: #000;
        border-color: #fff;
    }
</style> -->

<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Strummolo | Punk Narrative</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&family=Courier+Prime:ital@0;1&display=swap" rel="stylesheet">
    
    <style>
        /* --- GLOBAL STYLES --- */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            background-color: #050505;
            color: #fff;
            font-family: 'Courier Prime', 'Courier New', monospace;
            overflow-x: hidden;
            overflow-y: auto; /* Assicura che lo scroll verticale sia attivo */
            min-height: 100%;
            
            /* NASCONDE LA SCROLLBAR (Modifica 3) */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        /* Nascondi scrollbar per Chrome, Safari e Opera (Modifica 3) */
        body::-webkit-scrollbar, html::-webkit-scrollbar { 
            display: none; 
            width: 0;
            background: transparent;
        }

        /* Cursore */
        body, a, button {
            cursor: url('https://cur.cursors-4u.net/nature/nat-10/nat926.cur'), auto;
        }

        /* --- LAYOUT --- */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
            /* Filtro per look "consumato" */
            filter: contrast(130%) brightness(110%);
        }

        /* Overlay Rumore TV */
        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0.12;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.4' fill='white'/%3E%3C/svg%3E");
        }

        /* HEADER */
        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }

        .back-btn {
            pointer-events: auto;
            text-decoration: none;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            color: #fff;
            background: #000;
            padding: 10px;
            border: 1px solid #333;
            text-transform: uppercase;
            transition: 0.2s;
        }
        .back-btn:hover { background: #fff; color: #000; }

        /* --- SCROLL HINT (Modifica 2) --- */
        .scroll-hint {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: #fff;
            text-transform: uppercase;
            z-index: 2000;
            pointer-events: none;
            text-shadow: 0 2px 5px rgba(0,0,0,0.8);
            
            /* Animazione lampeggiante */
            animation: blink 1.5s infinite;
            transition: opacity 0.5s ease;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Classe per nascondere l'hint quando si scrolla */
        .scroll-hint.hidden {
            opacity: 0 !important;
            animation: none;
        }

        /* --- NARRATIVE TEXT (Overlay HTML) --- */
        .narrative-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .story-text {
            position: absolute;
            width: 80%;
            max-width: 600px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
            font-size: 1.4rem; /* Leggermente più grande per le frasi brevi */
            line-height: 1.6;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        
        .highlight {
            color: #ccc;
            font-style: italic;
            border-bottom: 1px dashed #555;
        }

        /* Stile specifico per la frase francese */
        #text-2 {
            font-style: italic;
            font-family: 'Times New Roman', serif; /* Tocco più classico per il francese */
        }

        @media (max-width: 600px) {
            .story-text { font-size: 1.1rem; }
        }

        /* --- SCROLL SPACER --- */
        #scroll-spacer {
            height: 15000px; 
            width: 1px;
            pointer-events: none;
            visibility: hidden;
        }

    </style>
</head>
<body>

    <div class="noise-overlay"></div>

    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <!-- Modifica 1: Nuovi testi -->
    <div class="narrative-layer">
        <div id="text-1" class="story-text">
            Lo strummolo gira sghembo.
        </div>
        <div id="text-2" class="story-text">
            Comme une jeunesse qui vacille.
        </div>
        <div id="text-3" class="story-text">
            La nostra gioventù.
        </div>
    </div>

    <!-- Modifica 2: Indicatore Scroll -->
    <div id="scroll-hint" class="scroll-hint">
        SCROLL DOWN ↓
    </div>

    <header>
        <a href="/" class="back-btn">← Home</a>
    </header>

    <div id="scroll-spacer"></div>

    <script>
        /**
         * CONFIGURAZIONE
         */
        const INTRO_HEIGHT = 6000; 
        const LOOP_BUFFER = 100;   
        
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const textElements = [
            document.getElementById('text-1'),
            document.getElementById('text-2'),
            document.getElementById('text-3')
        ];
        const scrollHint = document.getElementById('scroll-hint'); // Riferimento all'hint

        let width, height;
        let scrollY = 0;
        let ticking = false;

        // --- UTILITIES ---
        function random(min, max) { return Math.random() * (max - min) + min; }
        
        function mapRange(value, inMin, inMax, outMin, outMax) {
            return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
        }

        // --- DISEGNO STRUMMOLO (INTRO) ---
        function drawStrummolo(scrollProgress) {
            const progress01 = Math.min(scrollProgress / INTRO_HEIGHT, 1);
            
            const startY = height * 0.3;
            const endY = height * 0.8;
            const currentY = startY + (endY - startY) * progress01;
            const currentX = width / 2;

            const wobbleTime = Date.now() * 0.005 + (scrollProgress * 0.02); 
            const wobbleX = Math.sin(wobbleTime) * (10 + progress01 * 20);
            
            ctx.save();
            ctx.translate(currentX + wobbleX, currentY);
            
            const rotation = scrollProgress * 0.05; 
            ctx.rotate(rotation * Math.PI / 180);

            ctx.strokeStyle = `rgba(240, 240, 240, ${1 - progress01})`; 
            ctx.lineWidth = 2;
            
            const size = Math.min(width * 0.15, 80);
            const steps = 15;
            
            for (let i = 0; i < steps; i++) {
                const layerY = mapRange(i, 0, steps, -size, size * 1.5);
                const layerW = mapRange(i, 0, steps, size, 2); 
                
                ctx.beginPath();
                const deform = random(-2, 2);
                ctx.ellipse(deform, layerY, layerW, layerW * 0.4, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            if (progress01 < 0.3) {
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.bezierCurveTo(50, -100 - scrollProgress, -50, -150 - scrollProgress, 20, -250 - scrollProgress);
                ctx.strokeStyle = `rgba(255,255,255, ${0.5 - progress01})`;
                ctx.stroke();
            }

            ctx.restore();

            updateNarrativeOpacity(progress01);
        }

        function updateNarrativeOpacity(progress) {
            const fadeInOut = (el, start, end, curr) => {
                const middle = (start + end) / 2;
                const range = (end - start) / 2;
                let opacity = 1 - Math.abs(curr - middle) / range;
                
                opacity = Math.max(0, Math.min(1, opacity * 4)); 
                
                el.style.opacity = opacity;
                el.style.transform = `translateY(${mapRange(opacity, 0, 1, 20, 0)}px)`;
            };

            // Timing adattato per le 3 nuove frasi
            fadeInOut(textElements[0], 0.05, 0.35, progress); // Lo strummolo gira sghembo.
            fadeInOut(textElements[1], 0.35, 0.70, progress); // Comme une jeunesse...
            fadeInOut(textElements[2], 0.70, 0.95, progress); // La nostra.
        }

        // --- DISEGNO CHEST (DOPO INTRO) ---
        function drawChest() {
            const screenArea = width * height;
            const hairCount = Math.floor(screenArea * 0.0025); 
            const centerX = width / 2;
            const chestLevel = height * 0.35;
            const navelY = height * 0.75;
            
            const maxSpacing = 180;
            const nippleSpacing = Math.min(width * 0.22, maxSpacing);
            const nippleSize = Math.max(15, Math.min(width * 0.06, 30));

            const abdomenTopLimit = chestLevel + nippleSize + 20;
            const abdomenBottomLimit = navelY - 30;
            const abdomenCenterY = (abdomenTopLimit + abdomenBottomLimit) / 2;

            let boxWidth, boxHeight;
            if (width < 400) {
                boxWidth = Math.min(width * 0.8, 160);
                boxHeight = 70;
            } else {
                boxWidth = 300;
                boxHeight = 50;
            }
            const shavedTop = abdomenCenterY - (boxHeight / 2);
            const shavedBottom = abdomenCenterY + (boxHeight / 2);
            const shavedLeft = centerX - (boxWidth / 2);
            const shavedRight = centerX + (boxWidth / 2);

            ctx.beginPath(); 
            
            for (let i = 0; i < hairCount; i++) {
                let x = random(0, width);
                let y = random(0, height);
                
                if (x > shavedLeft && x < shavedRight && y > shavedTop && y < shavedBottom) continue;

                const distFromCenter = Math.abs(x - centerX);
                const safeZone = width < 600 ? width * 0.45 : width * 0.35;
                let drawProbability = 1;

                if (distFromCenter > safeZone) drawProbability = 0.6;
                if (y > chestLevel && y < navelY + 50) {
                     if (distFromCenter < width * 0.08) drawProbability = 1.8; 
                     else if (distFromCenter < width * 0.15) drawProbability = 0.9;
                } 

                if (Math.random() < drawProbability) {
                    const lenScale = width < 600 ? 0.8 : 1;
                    const length = random(8, 28) * lenScale;
                    let angle = Math.PI / 2; 
                    
                    if (x < centerX) angle += random(0.1, 0.5); 
                    if (x > centerX) angle -= random(0.1, 0.5);
                    
                    const distToNavel = Math.sqrt(Math.pow(x-centerX, 2) + Math.pow(y-navelY, 2));
                    if (distToNavel < 40) angle += random(-1, 1);

                    const activeScroll = scrollY - INTRO_HEIGHT;
                    const distortion = (activeScroll % 40) * 0.2; 
                    
                    const startX = x + random(-1,1);
                    const startY = y + random(-1,1);
                    
                    ctx.moveTo(startX, startY);
                    const cpX = startX + Math.cos(angle + random(-0.5, 0.5)) * (length/2) + distortion;
                    const cpY = startY + Math.sin(angle + random(-0.5, 0.5)) * (length/2);
                    const endX = startX + Math.cos(angle) * length;
                    const endY = startY + Math.sin(angle) * length;
                    
                    ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                }
            }
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            ctx.strokeStyle = `rgba(230, 230, 230, 0.7)`; 
            ctx.stroke();

            ctx.save();
            ctx.translate(centerX, abdomenCenterY);
            
            const brutalFonts = ['"Press Start 2P"', '"VT323"', '"Courier New"', '"Arial Black"', 'monospace'];
            const scrollIndex = Math.floor(scrollY / 50); 
            const currentFontFamily = brutalFonts[scrollIndex % brutalFonts.length];

            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            if (width < 400) {
                 ctx.font = `16px ${currentFontFamily}`; 
                 ctx.fillText("I HATE", 0, -15);
                 ctx.fillText("NAPOLI", 0, 15);
            } else {
                 ctx.font = `24px ${currentFontFamily}`; 
                 ctx.fillText("I HATE NAPOLI", 0, 0);
            }
            ctx.restore();

            drawNipple(centerX - nippleSpacing, chestLevel, nippleSize);
            drawNipple(centerX + nippleSpacing, chestLevel, nippleSize);
            drawNavel(centerX, navelY, nippleSize * 0.9);
            
            drawDirt(shavedLeft, shavedRight, shavedTop, shavedBottom);
        }

        function drawNipple(cx, cy, size) {
            const numRings = 12;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.9)"; 
            for(let i=0; i<numRings; i++) {
                ctx.beginPath();
                const r = (size * 0.3) + (i * (size/numRings)) + random(-2, 2);
                for (let a = 0; a <= Math.PI * 2; a += 0.3) { 
                    const x = cx + Math.cos(a) * r + random(-2, 2);
                    const y = cy + Math.sin(a) * r + random(-2, 2);
                    if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        function drawNavel(cx, cy, size) {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.85)";
            ctx.beginPath();
            let angle = 0; let r = 1;
            for (let i = 0; i < 30; i++) {
                 const x = cx + Math.cos(angle) * r + random(-1,1);
                 const y = cy + Math.sin(angle) * (r * 0.7) + random(-1,1);
                 if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x, y);
                 angle += 0.5; r += 0.3;
            }
            ctx.stroke();
        }

        function drawDirt(sl, sr, st, sb) {
            for(let j=0; j<40; j++) {
                ctx.beginPath();
                let sx = random(0, width);
                let sy = random(0, height);
                if (sx > sl && sx < sr && sy > st && sy < sb) continue;
                ctx.arc(sx, sy, random(1, 3), 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${random(0.1, 0.3)})`;
                ctx.fill();
            }
        }

        // --- MAIN RENDER LOOP ---
        function render() {
            if (!width || !height) return;

            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);

            if (scrollY < INTRO_HEIGHT) {
                drawStrummolo(scrollY);
            } else {
                drawChest();
            }
        }

        // --- LOGICA SCROLL E RESIZE ---
        function handleScroll() {
            scrollY = window.scrollY;

            // Modifica 2: Nascondi Hint se si scrolla
            if (scrollY > 50) {
                scrollHint.classList.add('hidden');
            } else {
                scrollHint.classList.remove('hidden');
            }

            // Infinite Scroll Logic
            if (scrollY >= INTRO_HEIGHT) {
                const docHeight = document.body.scrollHeight;
                const winHeight = window.innerHeight;
                
                if (scrollY + winHeight >= docHeight - LOOP_BUFFER) {
                    window.scrollTo(0, INTRO_HEIGHT + LOOP_BUFFER);
                    scrollY = INTRO_HEIGHT + LOOP_BUFFER;
                }
            }
            
            if (!ticking) {
                window.requestAnimationFrame(() => {
                    render();
                    ticking = false;
                });
                ticking = true;
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            scrollY = window.scrollY;
            render();
        }

        window.addEventListener('scroll', handleScroll);
        window.addEventListener('resize', resize);
        
        function animateLoop() {
            if (scrollY < INTRO_HEIGHT) {
                render();
            }
            requestAnimationFrame(animateLoop);
        }

        window.onload = () => {
            resize();
            animateLoop();
        };

    </script>
</body>
</html>