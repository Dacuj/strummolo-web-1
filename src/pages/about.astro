---
/* ABOUT.ASTRO
  Page: Punk Chest / Infinite Scroll
*/
---

<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>strummolo123 | Punk Chest</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
</head>
<body>

    <div class="noise-overlay"></div>

    <div id="canvas-container">
        <canvas id="chestCanvas"></canvas>
    </div>

    <header>
        <a href="/" class="back-btn">← Home</a>
    </header>

    <script>
        // @ts-nocheck
        const canvas = document.getElementById('chestCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let lastScrollY = window.scrollY;
        let ticking = false;

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Funzione di disegno principale
        function drawChest() {
            if (!width || !height || width <= 0 || height <= 0) return;

            // Pulisce il canvas
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);

            const screenArea = width * height;
            // Aumentato leggermente il numero totale di peli per compensare la distribuzione laterale
            const hairCount = Math.floor(screenArea * 0.0025); 

            const centerX = width / 2;
            const chestLevel = height * 0.35; // Livello Capezzoli
            const navelY = height * 0.75;     // Livello Ombelico
            
            const maxSpacing = 180;
            const nippleSpacing = Math.min(width * 0.22, maxSpacing);
            const nippleSize = Math.max(15, Math.min(width * 0.06, 30));

            // --- DEFINIZIONE ZONA "RASATA" ---
            // Calcoliamo il centro dell'area disponibile tra capezzoli e ombelico
            const abdomenTopLimit = chestLevel + nippleSize + 20;
            const abdomenBottomLimit = navelY - 30;
            const abdomenCenterY = (abdomenTopLimit + abdomenBottomLimit) / 2;

            // Definiamo dimensioni strette ("Tight bounding box") attorno al testo
            let boxWidth, boxHeight;
            if (width < 400) {
                // Mobile: Testo su due righe ("I HATE" / "NAPOLI")
                boxWidth = Math.min(width * 0.8, 160); // Ridotto rispetto al testo precedente
                boxHeight = 70; // Spazio sufficiente per 2 righe
            } else {
                // Desktop: Testo su una riga ("I HATE NAPOLI")
                boxWidth = 300; // Ridotto da 360 per adattarsi al testo più corto
                boxHeight = 50; // Spazio sufficiente per 1 riga
            }

            // Calcolo coordinate del rettangolo
            const shavedTop = abdomenCenterY - (boxHeight / 2);
            const shavedBottom = abdomenCenterY + (boxHeight / 2);
            const shavedLeft = centerX - (boxWidth / 2);
            const shavedRight = centerX + (boxWidth / 2);

            // 1. Peli
            ctx.beginPath(); 
            for (let i = 0; i < hairCount; i++) {
                let x = random(0, width);
                let y = random(0, height);
                
                // --- CONTROLLO ZONA RASATA ---
                if (x > shavedLeft && x < shavedRight && y > shavedTop && y < shavedBottom) {
                    continue; 
                }

                const distFromCenter = Math.abs(x - centerX);
                const safeZone = width < 600 ? width * 0.45 : width * 0.35;
                
                let drawProbability = 1;

                // --- DISTRIBUZIONE LATERALE ---
                if (distFromCenter > safeZone) {
                    drawProbability = 0.6; 
                }
                
                // Logica extra per la zona centrale
                if (y > chestLevel && y < navelY + 50) {
                     if (distFromCenter < width * 0.08) drawProbability = 1.8; 
                     else if (distFromCenter < width * 0.15) drawProbability = 0.9;
                } 

                if (Math.random() < drawProbability) {
                    const lenScale = width < 600 ? 0.8 : 1;
                    const length = random(8, 28) * lenScale;
                    let angle = Math.PI / 2; 
                    
                    if (x < centerX) angle += random(0.1, 0.5); 
                    if (x > centerX) angle -= random(0.1, 0.5);
                    
                    const distToNavel = Math.sqrt(Math.pow(x-centerX, 2) + Math.pow(y-navelY, 2));
                    if (distToNavel < 40) angle += random(-1, 1);

                    const distortion = (window.scrollY % 40) * 0.2; 
                    const startX = x + random(-1,1);
                    const startY = y + random(-1,1);
                    
                    ctx.moveTo(startX, startY);
                    const cpX = startX + Math.cos(angle + random(-0.5, 0.5)) * (length/2) + distortion;
                    const cpY = startY + Math.sin(angle + random(-0.5, 0.5)) * (length/2);
                    const endX = startX + Math.cos(angle) * length;
                    const endY = startY + Math.sin(angle) * length;
                    
                    ctx.quadraticCurveTo(cpX, cpY, endX, endY);
                }
            }
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            ctx.strokeStyle = `rgba(230, 230, 230, 0.7)`; 
            ctx.stroke();

            // --- DISEGNO SCRITTA "I HATE NAPOLI" ---
            ctx.save();
            ctx.translate(centerX, abdomenCenterY); // Usiamo il centro calcolato
            
            // Lista di font "duri" / brutalisti
            const brutalFonts = [
                '"Press Start 2P"', 
                '"VT323"', 
                '"Courier New"', 
                '"Arial Black"', 
                '"Impact"', 
                '"Times New Roman"', 
                '"Verdana"', 
                'monospace'
            ];

            const scrollIndex = Math.floor(window.scrollY / 150);
            const currentFontFamily = brutalFonts[scrollIndex % brutalFonts.length];

            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            ctx.fillStyle = "#fff";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // Disegna il testo
            if (width < 400) {
                 ctx.font = `16px ${currentFontFamily}`; 
                 ctx.fillText("I HATE", 0, -15);
                 ctx.fillText("NAPOLI", 0, 15);
            } else {
                 ctx.font = `24px ${currentFontFamily}`; 
                 ctx.fillText("I HATE NAPOLI", 0, 0);
            }
            
            ctx.restore();

            // 2. Anatomia
            drawNipple(centerX - nippleSpacing, chestLevel, nippleSize);
            drawNipple(centerX + nippleSpacing, chestLevel, nippleSize);
            drawNavel(centerX, navelY, nippleSize * 0.9);

            // 3. Graffi / Sporcizia
            for(let j=0; j<40; j++) {
                ctx.beginPath();
                let sx = random(0, width);
                let sy = random(0, height);
                // Evita di disegnare sporcizia sopra la scritta
                if (sx > shavedLeft && sx < shavedRight && sy > shavedTop && sy < shavedBottom) continue;

                const r = random(1, 3);
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${random(0.1, 0.3)})`;
                ctx.fill();
            }
        }

        function drawNipple(cx, cy, size) {
            const numRings = 12;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.9)"; 
            
            for(let i=0; i<numRings; i++) {
                ctx.beginPath();
                const r = (size * 0.3) + (i * (size/numRings)) + random(-2, 2);
                for (let a = 0; a <= Math.PI * 2; a += 0.3) { 
                    const x = cx + Math.cos(a) * r + random(-2, 2);
                    const y = cy + Math.sin(a) * r + random(-2, 2);
                    if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.lineWidth = random(0.8, 1.8);
                ctx.stroke();
            }
            
            // Centro
            ctx.beginPath();
            for(let k=0; k<20; k++) {
                const r = random(0, size * 0.3);
                const a = random(0, Math.PI * 2);
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(a)*r, cy + Math.sin(a)*r);
            }
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawNavel(cx, cy, size) {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.85)";
            ctx.beginPath();
            let angle = 0;
            let r = 1;
            
            for (let i = 0; i < 30; i++) {
                 const x = cx + Math.cos(angle) * r + random(-1,1);
                 const y = cy + Math.sin(angle) * (r * 0.7) + random(-1,1);
                 if(i===0) ctx.moveTo(x,y);
                 else ctx.lineTo(x, y);
                 angle += 0.5;
                 r += 0.3;
            }
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(cx - size, cy - size*0.6);
            ctx.quadraticCurveTo(cx, cy - size*1.2, cx + size, cy - size*0.6);
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgba(255,255,255,0.4)";
            ctx.stroke();
        }

        function resize() {
            const dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            
            if (width === 0 || height === 0) {
                setTimeout(resize, 100);
                return;
            }

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            
            drawChest();
        }

        // --- GESTIONE SCROLL INFINITO ---
        function checkInfiniteScroll() {
            const scrollPos = window.scrollY;
            const docHeight = document.body.scrollHeight;
            const winHeight = window.innerHeight;
            const buffer = 100; // Pixel di margine prima del loop

            // Se arriviamo quasi in fondo, saltiamo indietro (loop)
            if (scrollPos + winHeight >= docHeight - buffer) {
                window.scrollTo(0, buffer + 1);
            }
            // Se arriviamo in cima, saltiamo quasi in fondo
            else if (scrollPos <= 0) {
                window.scrollTo(0, docHeight - winHeight - buffer - 1);
            }
        }

        window.addEventListener('scroll', () => {
            // Effetto glitch/distorsione
            const currentScroll = window.scrollY;
            const threshold = 10; 

            if (Math.abs(currentScroll - lastScrollY) > threshold) {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        drawChest();
                        checkInfiniteScroll(); // Controlla il loop
                        ticking = false;
                    });
                    ticking = true;
                }
                lastScrollY = currentScroll;
            } else {
                // Controllo immediato per il loop anche su piccoli scroll
                checkInfiniteScroll();
            }
        });

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resize, 100);
        });
        
        window.onload = () => {
            resize();
            // Start scroll middle
            window.scrollTo(0, 100);
        };
        // Backup per Astro transitions
        document.addEventListener('DOMContentLoaded', resize);

    </script>
</body>
</html>

<style is:global>
    /* --- IMPOSTAZIONI DI BASE & SFONDO --- */
    body, html {
        margin: 0;
        padding: 0;
        width: 100%;
        /* Altezza molto grande per permettere lo scroll, gestita poi dal JS per il loop */
        height: 5000px; 
        background-color: #050505; 
        font-family: 'Courier New', Courier, monospace;
        -webkit-overflow-scrolling: touch;
        /* Cursore personalizzato */
        cursor: url('https://cur.cursors-4u.net/nature/nat-10/nat926.cur'), auto;
        
        /* --- NASCONDI SCROLLBAR (Richiesta 1) --- */
        /* Per Firefox */
        scrollbar-width: none;
        /* Per IE e Edge */
        -ms-overflow-style: none;
    }

    /* Per Chrome, Safari e Opera */
    body::-webkit-scrollbar {
        display: none;
    }

    /* Il canvas è sullo sfondo fisso */
    #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1; 
        pointer-events: none; 
        filter: contrast(150%) brightness(120%);
    }

    /* Overlay rumore */
    .noise-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
        opacity: 0.15;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.4' fill='white'/%3E%3C/svg%3E");
        mix-blend-mode: screen; 
    }

    /* Elementi Interattivi */
    a, button, .logo, .nav-link {
        cursor: url('https://cur.cursors-4u.net/nature/nat-10/nat926.cur'), pointer;
    }

    /* --- HEADER & NAVBAR --- */
    /* --- HEADER (Minimal) --- */
    header {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        padding: 20px;
        z-index: 1000;
        display: flex;
        justify-content: space-between;
        pointer-events: none; 
    }

    .back-btn {
        pointer-events: auto;
        text-decoration: none;
        font-family: 'Press Start 2P', cursive;
        font-size: 0.7rem;
        color: #fff;
        background: #000;
        padding: 10px;
        border: 1px solid #333;
        transition: all 0.2s;
        text-transform: uppercase;
    }

    .back-btn:hover {
        background: #fff;
        color: #000;
        border-color: #fff;
    }
</style>